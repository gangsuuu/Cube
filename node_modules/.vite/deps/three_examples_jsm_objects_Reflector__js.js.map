{
  "version": 3,
  "sources": ["../../three/examples/jsm/objects/Reflector.js"],
  "sourcesContent": ["import {\r\n\tColor,\r\n\tMatrix4,\r\n\tMesh,\r\n\tPerspectiveCamera,\r\n\tPlane,\r\n\tShaderMaterial,\r\n\tUniformsUtils,\r\n\tVector3,\r\n\tVector4,\r\n\tWebGLRenderTarget,\r\n\tHalfFloatType,\r\n\tNoToneMapping,\r\n\tLinearEncoding\r\n} from 'three';\r\n\r\nclass Reflector extends Mesh {\r\n\r\n\tconstructor( geometry, options = {} ) {\r\n\r\n\t\tsuper( geometry );\r\n\r\n\t\tthis.isReflector = true;\r\n\r\n\t\tthis.type = 'Reflector';\r\n\t\tthis.camera = new PerspectiveCamera();\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tconst color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0x7F7F7F );\r\n\t\tconst textureWidth = options.textureWidth || 512;\r\n\t\tconst textureHeight = options.textureHeight || 512;\r\n\t\tconst clipBias = options.clipBias || 0;\r\n\t\tconst shader = options.shader || Reflector.ReflectorShader;\r\n\t\tconst multisample = ( options.multisample !== undefined ) ? options.multisample : 4;\r\n\r\n\t\t//\r\n\r\n\t\tconst reflectorPlane = new Plane();\r\n\t\tconst normal = new Vector3();\r\n\t\tconst reflectorWorldPosition = new Vector3();\r\n\t\tconst cameraWorldPosition = new Vector3();\r\n\t\tconst rotationMatrix = new Matrix4();\r\n\t\tconst lookAtPosition = new Vector3( 0, 0, - 1 );\r\n\t\tconst clipPlane = new Vector4();\r\n\r\n\t\tconst view = new Vector3();\r\n\t\tconst target = new Vector3();\r\n\t\tconst q = new Vector4();\r\n\r\n\t\tconst textureMatrix = new Matrix4();\r\n\t\tconst virtualCamera = this.camera;\r\n\r\n\t\tconst renderTarget = new WebGLRenderTarget( textureWidth, textureHeight, { samples: multisample, type: HalfFloatType } );\r\n\r\n\t\tconst material = new ShaderMaterial( {\r\n\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\r\n\t\t\tfragmentShader: shader.fragmentShader,\r\n\t\t\tvertexShader: shader.vertexShader\r\n\t\t} );\r\n\r\n\t\tmaterial.uniforms[ 'tDiffuse' ].value = renderTarget.texture;\r\n\t\tmaterial.uniforms[ 'color' ].value = color;\r\n\t\tmaterial.uniforms[ 'textureMatrix' ].value = textureMatrix;\r\n\r\n\t\tthis.material = material;\r\n\r\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\r\n\r\n\t\t\treflectorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\r\n\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\r\n\r\n\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\r\n\r\n\t\t\tnormal.set( 0, 0, 1 );\r\n\t\t\tnormal.applyMatrix4( rotationMatrix );\r\n\r\n\t\t\tview.subVectors( reflectorWorldPosition, cameraWorldPosition );\r\n\r\n\t\t\t// Avoid rendering when reflector is facing away\r\n\r\n\t\t\tif ( view.dot( normal ) > 0 ) return;\r\n\r\n\t\t\tview.reflect( normal ).negate();\r\n\t\t\tview.add( reflectorWorldPosition );\r\n\r\n\t\t\trotationMatrix.extractRotation( camera.matrixWorld );\r\n\r\n\t\t\tlookAtPosition.set( 0, 0, - 1 );\r\n\t\t\tlookAtPosition.applyMatrix4( rotationMatrix );\r\n\t\t\tlookAtPosition.add( cameraWorldPosition );\r\n\r\n\t\t\ttarget.subVectors( reflectorWorldPosition, lookAtPosition );\r\n\t\t\ttarget.reflect( normal ).negate();\r\n\t\t\ttarget.add( reflectorWorldPosition );\r\n\r\n\t\t\tvirtualCamera.position.copy( view );\r\n\t\t\tvirtualCamera.up.set( 0, 1, 0 );\r\n\t\t\tvirtualCamera.up.applyMatrix4( rotationMatrix );\r\n\t\t\tvirtualCamera.up.reflect( normal );\r\n\t\t\tvirtualCamera.lookAt( target );\r\n\r\n\t\t\tvirtualCamera.far = camera.far; // Used in WebGLBackground\r\n\r\n\t\t\tvirtualCamera.updateMatrixWorld();\r\n\t\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\r\n\r\n\t\t\t// Update the texture matrix\r\n\t\t\ttextureMatrix.set(\r\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\r\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\r\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\r\n\t\t\t\t0.0, 0.0, 0.0, 1.0\r\n\t\t\t);\r\n\t\t\ttextureMatrix.multiply( virtualCamera.projectionMatrix );\r\n\t\t\ttextureMatrix.multiply( virtualCamera.matrixWorldInverse );\r\n\t\t\ttextureMatrix.multiply( scope.matrixWorld );\r\n\r\n\t\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\r\n\t\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\r\n\t\t\treflectorPlane.setFromNormalAndCoplanarPoint( normal, reflectorWorldPosition );\r\n\t\t\treflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\r\n\r\n\t\t\tclipPlane.set( reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant );\r\n\r\n\t\t\tconst projectionMatrix = virtualCamera.projectionMatrix;\r\n\r\n\t\t\tq.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\r\n\t\t\tq.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\r\n\t\t\tq.z = - 1.0;\r\n\t\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\r\n\r\n\t\t\t// Calculate the scaled plane vector\r\n\t\t\tclipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );\r\n\r\n\t\t\t// Replacing the third row of the projection matrix\r\n\t\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\r\n\t\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\r\n\t\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;\r\n\t\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\r\n\r\n\t\t\t// Render\r\n\t\t\tscope.visible = false;\r\n\r\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\r\n\r\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\r\n\t\t\tconst currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\r\n\t\t\tconst currentOutputEncoding = renderer.outputEncoding;\r\n\t\t\tconst currentToneMapping = renderer.toneMapping;\r\n\r\n\t\t\trenderer.xr.enabled = false; // Avoid camera modification\r\n\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\r\n\t\t\trenderer.outputEncoding = LinearEncoding;\r\n\t\t\trenderer.toneMapping = NoToneMapping;\r\n\r\n\t\t\trenderer.setRenderTarget( renderTarget );\r\n\r\n\t\t\trenderer.state.buffers.depth.setMask( true ); // make sure the depth buffer is writable so it can be properly cleared, see #18897\r\n\r\n\t\t\tif ( renderer.autoClear === false ) renderer.clear();\r\n\t\t\trenderer.render( scene, virtualCamera );\r\n\r\n\t\t\trenderer.xr.enabled = currentXrEnabled;\r\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\r\n\t\t\trenderer.outputEncoding = currentOutputEncoding;\r\n\t\t\trenderer.toneMapping = currentToneMapping;\r\n\r\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\r\n\r\n\t\t\t// Restore viewport\r\n\r\n\t\t\tconst viewport = camera.viewport;\r\n\r\n\t\t\tif ( viewport !== undefined ) {\r\n\r\n\t\t\t\trenderer.state.viewport( viewport );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tscope.visible = true;\r\n\r\n\t\t};\r\n\r\n\t\tthis.getRenderTarget = function () {\r\n\r\n\t\t\treturn renderTarget;\r\n\r\n\t\t};\r\n\r\n\t\tthis.dispose = function () {\r\n\r\n\t\t\trenderTarget.dispose();\r\n\t\t\tscope.material.dispose();\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n}\r\n\r\nReflector.ReflectorShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t'color': {\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'tDiffuse': {\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'textureMatrix': {\r\n\t\t\tvalue: null\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tvertexShader: /* glsl */`\r\n\t\tuniform mat4 textureMatrix;\r\n\t\tvarying vec4 vUv;\r\n\r\n\t\t#include <common>\r\n\t\t#include <logdepthbuf_pars_vertex>\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\t#include <logdepthbuf_vertex>\r\n\r\n\t\t}`,\r\n\r\n\tfragmentShader: /* glsl */`\r\n\t\tuniform vec3 color;\r\n\t\tuniform sampler2D tDiffuse;\r\n\t\tvarying vec4 vUv;\r\n\r\n\t\t#include <logdepthbuf_pars_fragment>\r\n\r\n\t\tfloat blendOverlay( float base, float blend ) {\r\n\r\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\r\n\r\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\r\n\r\n\t\t}\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\t#include <logdepthbuf_fragment>\r\n\r\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\r\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\r\n\r\n\t\t\t#include <tonemapping_fragment>\r\n\t\t\t#include <encodings_fragment>\r\n\r\n\t\t}`\r\n};\r\n\r\nexport { Reflector };\r\n"],
  "mappings": "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",
  "names": []
}
